class Memory {

 static Array ram;
 static int head, heap;

    function void init() {
        var int heapSize;

    let ram = 0;
    let heap = 2048;
    let head = heap;
    let heapSize = 14336; // heap segment is: 2048-16384
  
    do Memory.poke(head, 0); 
    do Memory.poke(head + 1, heapSize); 

    return;

    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        var int value;
        let value = ram[address];
        return value;
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let ram[address] = value;
        return;

    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    
    
   function void defrag() {
    var int curr, next, currSize, nextSize, nextNext, mergedSize;
     let curr = head;

     while(curr) { // if curr 0 stop
        let next = Memory.peek(curr);
        let currSize = Memory.peek(curr + 1);
        if((curr + currSize) = next) {
            // we are adjacent so merge;
            let nextSize = Memory.peek(next + 1);
            let nextNext = Memory.peek(next);
            let mergedSize = nextSize + currSize;
            do Memory.poke(curr, nextNext);
            do Memory.poke(curr + 1, mergedSize);

            
            
        }
        if (~((curr + currSize) = next)){
    let curr = next;

        }
   
    
     }
     return;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {  
       var int curr, objectSize, newNext, segmentAddress, nextPointer, prev;
       

        let objectSize = Memory.peek(o - 1); 
        let curr = head;
        let segmentAddress = o - 2; 
        let prev = 0;
        // not keeping track of prev to merge linked list
        while (curr) {
            let nextPointer = Memory.peek(curr);
        if (curr > segmentAddress) { 
            // put o before curr
            if (prev = 0) {
            
                let head = segmentAddress;
                do Memory.poke(head, curr); // if no previous we make the deallocated object the head
                do Memory.poke(head + 1, objectSize + 2);
                return;
            }
            do Memory.poke(prev, segmentAddress); // prev points to old obj address since itsin middle
            let newNext = curr;  // newNext = pointer ahead of deallocated obj
            let curr = segmentAddress; // curr is deallocated obj
            do Memory.poke(curr, newNext); // now our old object points to prevHead
            do Memory.poke(curr + 1, objectSize + 2);
            return;
        }
         let prev = curr; // prev is one before curr
        let curr = nextPointer; 

}

// if we are here, it means we are at the end of the list so append at the end // curr is 0
do Memory.poke(prev, segmentAddress);
do Memory.poke(segmentAddress, 0); // now our last node points to null;
do Memory.poke(segmentAddress + 1, objectSize + 2);


 
return;
}


function int tryAlloc(int size) {
     var int curr, neededSize, next, segmentSize, addrToReturn, remainingHeap, prev;
        let neededSize = size + 2;
        let curr = head;

        let prev = 0; 
       while( (curr) & ((curr + neededSize) < 16385)) {

            let segmentSize = Memory.peek(curr + 1);
            let next = Memory.peek(curr); 

                if (~(neededSize > segmentSize)) {
                let remainingHeap = segmentSize - neededSize; // new size of remaining segment
                let addrToReturn = curr + 2;
           
                do Memory.poke(curr + 1, size); // put obj size theres
                do Memory.poke(curr, 0);// => no need to point at anything anymore its taken // this address now isnt really a pointer since its part of an object, it doesnt have a meaningful basis // remember when dealloc that this field means nothing
                
                 
                if (remainingHeap > 2) {
                       if (prev = 0) { 
                        // no prev, update head
                    let head = curr + neededSize;
                    do Memory.poke(head, next);
                    do Memory.poke(head + 1, remainingHeap);
                    return addrToReturn;
                }

                let curr = curr + neededSize;

                do Memory.poke(curr, next); // remaining segment points to curr.next
                do Memory.poke(curr + 1, remainingHeap); 
                do Memory.poke(prev, curr); 

                return addrToReturn; 
                
                }
                 // if we are here then the remanining heap is too small for new objects( size + 2 fields housework), we just do head = head.next
                 if (prev = 0){
                    let head = next;
                    return addrToReturn;
                 }
                 do Memory.poke(prev, next);
                  return addrToReturn;
                    
            }

            let prev = curr;
            let curr = next; 

     

        }

// failed if we are here
        return 0;

} 

function Array alloc(int size) {
    var int addrToReturn;
   
    let addrToReturn = Memory.tryAlloc(size);
    if (addrToReturn = 0) {
        // failed 
        do Memory.defrag();
        let addrToReturn = Memory.tryAlloc(size); // one more try
    }
    
    return addrToReturn; // if its still 0 = failed


}
}